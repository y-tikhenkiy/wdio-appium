export type DeferredPromise = {
    promise: B<any>;
    resolve: (...args: any[]) => void;
    reject: (err?: Error) => void;
};
export type AppInfo = {
    id: string;
    isProxy: boolean;
    name: string;
    bundleId: string;
    hostId: string;
    isActive: boolean;
    isAutomationEnabled: boolean | string;
    pageArray?: any[] | undefined | DeferredPromise;
};
/**
 * @typedef {Object} DeferredPromise
 * @property {B<any>} promise
 * @property {(...args: any[]) => void} resolve
 * @property {(err?: Error) => void} reject
 */
/**
 * @typedef {Object} AppInfo
 * @property {string} id
 * @property {boolean} isProxy
 * @property {string} name
 * @property {string} bundleId
 * @property {string} hostId
 * @property {boolean} isActive
 * @property {boolean|string} isAutomationEnabled
 * @property {any[]|undefined|DeferredPromise} [pageArray]
 */
/**
 * Takes a dictionary from the remote debugger and makes a more manageable
 * dictionary whose keys are understandable
 *
 * @param {Record<string, any>} dict
 * @returns {[string, AppInfo]}
 */
export function appInfoFromDict(dict: Record<string, any>): [string, AppInfo];
export function pageArrayFromDict(pageDict: any): any[];
/**
 * Given a bundle id, finds the correct remote debugger app that is
 * connected.
 * @param {string} bundleId
 * @param {Record<string, any>} appDict
 * @returns {string|undefined}
 */
export function getDebuggerAppKey(bundleId: string, appDict: Record<string, any>): string | undefined;
/**
 * Find app keys based on assigned bundleIds from appDict
 * When bundleIds includes a wildcard ('*'), returns all appKeys in appDict.
 * @param {string[]} bundleIds
 * @param {Record<string, any>} appDict
 * @returns {string[]}
 */
export function getPossibleDebuggerAppKeys(bundleIds: string[], appDict: Record<string, any>): string[];
export function checkParams(params: any): void;
export function simpleStringify(value: any, multiline?: boolean): string;
/**
 * @returns {DeferredPromise}
 */
export function deferredPromise(): DeferredPromise;
export function convertResult(res: any): any;
export const RESPONSE_LOG_LENGTH: 100;
/**
 * Calculates the path to the current module's root folder
 *
 * @returns {string} The full path to module root
 * @throws {Error} If the current module root folder cannot be determined
 */
export const getModuleRoot: (() => string) & _.MemoizedFunction;
import B from 'bluebird';
import _ from 'lodash';
//# sourceMappingURL=utils.d.ts.map
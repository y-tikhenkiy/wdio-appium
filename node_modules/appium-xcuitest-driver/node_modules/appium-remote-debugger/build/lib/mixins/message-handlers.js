"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("../logger"));
const events_1 = __importDefault(require("./events"));
const utils_1 = require("../utils");
const lodash_1 = __importDefault(require("lodash"));
/*
 * Generic callbacks used throughout the lifecycle of the Remote Debugger.
 * These will be added to the prototype.
 */
/**
 * @this {import('../remote-debugger').RemoteDebugger}
 * @param {Error?} err
 * @param {string} appIdKey
 * @param {Record<string, any>} pageDict
 * @returns {Promise<void>}
 */
async function onPageChange(err, appIdKey, pageDict) {
    if (lodash_1.default.isEmpty(pageDict)) {
        return;
    }
    const pageArray = (0, utils_1.pageArrayFromDict)(pageDict);
    await this.useAppDictLock((done) => {
        try {
            // save the page dict for this app
            if (this.appDict[appIdKey]) {
                if (this.appDict[appIdKey].pageArray) {
                    if (this.appDict[appIdKey].pageArray.resolve) {
                        // pageDict is a pending promise, so resolve
                        this.appDict[appIdKey].pageArray.resolve();
                    }
                    else {
                        // we have a pre-existing pageDict
                        if (lodash_1.default.isEqual(this.appDict[appIdKey].pageArray, pageArray)) {
                            logger_1.default.debug(`Received page change notice for app '${appIdKey}' ` +
                                `but the listing has not changed. Ignoring.`);
                            return done();
                        }
                    }
                }
                // keep track of the page dictionary
                this.appDict[appIdKey].pageArray = pageArray;
            }
        }
        finally {
            done();
        }
    });
    if (this._navigatingToPage) {
        // in the middle of navigating, so reporting a page change will cause problems
        return;
    }
    logger_1.default.debug(`Page changed: ${(0, utils_1.simpleStringify)(pageDict, true)}`);
    this.emit(events_1.default.EVENT_PAGE_CHANGE, {
        appIdKey: appIdKey.replace('PID:', ''),
        pageArray,
    });
}
/**
 * @this {import('../remote-debugger').RemoteDebugger}
 * @param {Error?} err
 * @param {Record<string, any>} dict
 * @returns {Promise<void>}
 */
async function onAppConnect(err, dict) {
    const appIdKey = dict.WIRApplicationIdentifierKey;
    logger_1.default.debug(`Notified that new application '${appIdKey}' has connected`);
    await this.useAppDictLock((/** @type {() => Void} */ done) => {
        try {
            this.updateAppsWithDict(dict);
        }
        finally {
            done();
        }
    });
}
/**
 * @this {import('../remote-debugger').RemoteDebugger}
 * @param {Error?} err
 * @param {Record<string, any>} dict
 * @returns {void}
 */
function onAppDisconnect(err, dict) {
    const appIdKey = dict.WIRApplicationIdentifierKey;
    logger_1.default.debug(`Application '${appIdKey}' disconnected. Removing from app dictionary.`);
    logger_1.default.debug(`Current app is '${this.appIdKey}'`);
    // get rid of the entry in our app dictionary,
    // since it is no longer available
    delete this.appDict[appIdKey];
    // if the disconnected app is the one we are connected to, try to find another
    if (this.appIdKey === appIdKey) {
        logger_1.default.debug(`No longer have app id. Attempting to find new one.`);
        this.appIdKey = (0, utils_1.getDebuggerAppKey)(this.bundleId, this.appDict);
    }
    if (!this.appDict) {
        // this means we no longer have any apps. what the what?
        logger_1.default.debug('Main app disconnected. Disconnecting altogether.');
        this.connected = false;
        this.emit(events_1.default.EVENT_DISCONNECT, true);
    }
}
/**
 * @this {import('../remote-debugger').RemoteDebugger}
 * @param {Error?} err
 * @param {Record<string, any>} dict
 * @returns {Promise<void>}
 */
async function onAppUpdate(err, dict) {
    await this.useAppDictLock((done) => {
        try {
            this.updateAppsWithDict(dict);
        }
        finally {
            done();
        }
    });
}
/**
 * @this {import('../remote-debugger').RemoteDebugger}
 * @param {Error?} err
 * @param {Record<string, any>} drivers
 * @returns {void}
 */
function onConnectedDriverList(err, drivers) {
    this.connectedDrivers = drivers.WIRDriverDictionaryKey;
    logger_1.default.debug(`Received connected driver list: ${JSON.stringify(this.connectedDrivers)}`);
}
/**
 * @this {import('../remote-debugger').RemoteDebugger}
 * @param {Error?} err
 * @param {Record<string, any>} state
 * @returns {void}
 */
function onCurrentState(err, state) {
    this.currentState = state.WIRAutomationAvailabilityKey;
    // This state changes when 'Remote Automation' in 'Settings app' > 'Safari' > 'Advanced' > 'Remote Automation' changes
    // WIRAutomationAvailabilityAvailable or WIRAutomationAvailabilityNotAvailable
    logger_1.default.debug(`Received connected automation availability state: ${JSON.stringify(this.currentState)}`);
}
/**
 * @this {import('../remote-debugger').RemoteDebugger}
 * @param {Error?} err
 * @param {Record<string, any>} apps
 * @returns {Promise<void>}
 */
async function onConnectedApplicationList(err, apps) {
    logger_1.default.debug(`Received connected applications list: ${lodash_1.default.keys(apps).join(', ')}`);
    // translate the received information into an easier-to-manage
    // hash with app id as key, and app info as value
    let newDict = {};
    for (const dict of lodash_1.default.values(apps)) {
        const [id, entry] = (0, utils_1.appInfoFromDict)(dict);
        if (this.skippedApps.includes(entry.name)) {
            continue;
        }
        newDict[id] = entry;
    }
    // update the object's list of apps
    await this.useAppDictLock((done) => {
        try {
            lodash_1.default.defaults(this.appDict, newDict);
        }
        finally {
            done();
        }
    });
}
const messageHandlers = {
    onPageChange,
    onAppConnect,
    onAppDisconnect,
    onAppUpdate,
    onConnectedDriverList,
    onCurrentState,
    onConnectedApplicationList,
};
exports.default = messageHandlers;
//# sourceMappingURL=message-handlers.js.map
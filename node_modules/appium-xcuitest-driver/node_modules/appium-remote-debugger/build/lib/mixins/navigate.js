"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("../logger"));
const utils_1 = require("../utils");
const events_1 = __importDefault(require("./events"));
const support_1 = require("@appium/support");
const lodash_1 = __importDefault(require("lodash"));
const bluebird_1 = __importDefault(require("bluebird"));
const base_driver_1 = require("@appium/base-driver");
const rpc_1 = require("../rpc");
const DEFAULT_PAGE_READINESS_TIMEOUT_MS = 20 * 1000;
const PAGE_READINESS_CHECK_INTERVAL_MS = 50;
const PAGE_READINESS_JS_MIN_CHECK_INTERVAL_MS = 1000;
const CONSOLE_ENABLEMENT_TIMEOUT_MS = 20 * 1000;
/**
 * @this {import('../remote-debugger').RemoteDebugger}
 * @returns {void}
 */
function frameDetached() {
    this.emit(events_1.default.EVENT_FRAMES_DETACHED);
}
/**
 * @this {import('../remote-debugger').RemoteDebugger}
 * @returns {void}
 */
function cancelPageLoad() {
    logger_1.default.debug('Unregistering from page readiness notifications');
    this.pageLoading = false;
    if (this.pageLoadDelay) {
        this.pageLoadDelay.cancel();
    }
}
/**
 * @this {import('../remote-debugger').RemoteDebugger}
 * @param {timing.Timer|null|undefined} startPageLoadTimer
 * @returns {Promise<void>}
 */
async function waitForDom(startPageLoadTimer) {
    logger_1.default.debug('Waiting for page readiness');
    const readinessTimeoutMs = this.pageLoadMs || DEFAULT_PAGE_READINESS_TIMEOUT_MS;
    if (!lodash_1.default.isFunction(startPageLoadTimer?.getDuration)) {
        logger_1.default.debug(`Page load timer not a timer. Creating new timer`);
        startPageLoadTimer = new support_1.timing.Timer().start();
    }
    let isPageLoading = true;
    this.pageLoading = true;
    this.pageLoadDelay = support_1.util.cancellableDelay(readinessTimeoutMs);
    /** @type {B<void>} */
    const pageReadinessPromise = bluebird_1.default.resolve((async () => {
        let retry = 0;
        while (isPageLoading) {
            // if we are ready, or we've spend too much time on this
            // @ts-ignore startPageLoadTimer is defined here
            const elapsedMs = startPageLoadTimer.getDuration().asMilliSeconds;
            // exponential retry
            const intervalMs = Math.min(PAGE_READINESS_CHECK_INTERVAL_MS * Math.pow(2, retry), readinessTimeoutMs - elapsedMs);
            await bluebird_1.default.delay(intervalMs);
            // we can get this called in the middle of trying to find a new app
            if (!this.appIdKey) {
                logger_1.default.debug('Not connected to an application. Ignoring page readiess check');
                return;
            }
            if (!isPageLoading) {
                return;
            }
            if (await this.checkPageIsReady()) {
                if (isPageLoading) {
                    logger_1.default.debug(`Page is ready in ${elapsedMs}ms`);
                    isPageLoading = false;
                }
                return;
            }
            if (elapsedMs > readinessTimeoutMs) {
                logger_1.default.info(`Timed out after ${readinessTimeoutMs}ms of waiting for the page readiness. Continuing anyway`);
                isPageLoading = false;
                return;
            }
            retry++;
        }
    })());
    /** @type {B<void>} */
    const cancellationPromise = bluebird_1.default.resolve((async () => {
        try {
            await this.pageLoadDelay;
        }
        catch (ign) { }
    })());
    try {
        await bluebird_1.default.any([cancellationPromise, pageReadinessPromise]);
    }
    finally {
        isPageLoading = false;
        this.pageLoading = false;
        this.pageLoadDelay = bluebird_1.default.resolve();
    }
}
/**
 * @this {import('../remote-debugger').RemoteDebugger}
 * @param {number} [timeoutMs]
 * @returns {Promise<boolean>}
 */
async function checkPageIsReady(timeoutMs) {
    (0, utils_1.checkParams)({ appIdKey: this.appIdKey });
    const readyCmd = 'document.readyState;';
    try {
        const readyState = await bluebird_1.default.resolve(this.execute(readyCmd, true))
            .timeout(timeoutMs ?? this.pageReadyTimeout);
        logger_1.default.debug(`Document readyState is '${readyState}'`);
        return readyState === 'complete';
    }
    catch (err) {
        if (!(err instanceof bluebird_1.default.TimeoutError)) {
            throw err;
        }
        logger_1.default.debug(`Page readiness check timed out after ${this.pageReadyTimeout}ms`);
        return false;
    }
}
/**
 * @this {import('../remote-debugger').RemoteDebugger}
 * @param {string} url
 * @returns {Promise<void>}
 */
async function navToUrl(url) {
    (0, utils_1.checkParams)({ appIdKey: this.appIdKey, pageIdKey: this.pageIdKey });
    if (!this.rpcClient) {
        throw new Error('rpcClient is undefined. Is the debugger connected?');
    }
    try {
        new URL(url);
    }
    catch (e) {
        throw new TypeError(`'${url}' is not a valid URL`);
    }
    this._navigatingToPage = true;
    logger_1.default.debug(`Navigating to new URL: '${url}'`);
    const readinessTimeoutMs = this.pageLoadMs || DEFAULT_PAGE_READINESS_TIMEOUT_MS;
    /** @type {(() => void)|undefined} */
    let onPageLoaded;
    /** @type {(() => void)|undefined} */
    let onTargetProvisioned;
    /** @type {NodeJS.Timeout|undefined|null} */
    let onPageLoadedTimeout;
    this.pageLoadDelay = support_1.util.cancellableDelay(readinessTimeoutMs);
    this.pageLoading = true;
    let isPageLoading = true;
    let didPageFinishLoad = false;
    const start = new support_1.timing.Timer().start();
    /** @type {B<void>} */
    const pageReadinessPromise = new bluebird_1.default((resolve) => {
        onPageLoadedTimeout = setTimeout(() => {
            if (isPageLoading) {
                isPageLoading = false;
                logger_1.default.info(`Timed out after ${start.getDuration().asMilliSeconds.toFixed(0)}ms of waiting ` +
                    `for the ${url} page readiness. Continuing anyway`);
            }
            return resolve();
        }, readinessTimeoutMs);
        onPageLoaded = () => {
            if (isPageLoading) {
                isPageLoading = false;
                logger_1.default.debug(`The page ${url} is ready in ${start.getDuration().asMilliSeconds.toFixed(0)}ms`);
            }
            if (onPageLoadedTimeout) {
                clearTimeout(onPageLoadedTimeout);
                onPageLoadedTimeout = null;
            }
            didPageFinishLoad = true;
            return resolve();
        };
        // https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-loadEventFired
        this.rpcClient?.once('Page.loadEventFired', onPageLoaded);
        // Pages that have no proper DOM structure do not fire the `Page.loadEventFired` event
        // so we rely on the very first event after target change, which is `onTargetProvisioned`
        // and start sending `document.readyState` requests until we either succeed or
        // another event/timeout happens
        onTargetProvisioned = async () => {
            while (isPageLoading) {
                const pageReadyCheckStart = new support_1.timing.Timer().start();
                try {
                    const isReady = await this.checkPageIsReady(PAGE_READINESS_JS_MIN_CHECK_INTERVAL_MS);
                    if (isReady && isPageLoading && onPageLoaded) {
                        return onPageLoaded();
                    }
                }
                catch (ign) { }
                const msLeft = PAGE_READINESS_JS_MIN_CHECK_INTERVAL_MS - pageReadyCheckStart.getDuration().asMilliSeconds;
                if (msLeft > 0 && isPageLoading) {
                    await bluebird_1.default.delay(msLeft);
                }
            }
        };
        this.rpcClient?.targetSubscriptions.once(rpc_1.rpcConstants.ON_TARGET_PROVISIONED_EVENT, onTargetProvisioned);
        this.rpcClient?.send('Page.navigate', {
            url,
            appIdKey: this.appIdKey,
            pageIdKey: this.pageIdKey,
        });
    });
    /** @type {B<void>} */
    const cancellationPromise = bluebird_1.default.resolve((async () => {
        try {
            await this.pageLoadDelay;
        }
        catch (ign) { }
    })());
    try {
        await bluebird_1.default.any([cancellationPromise, pageReadinessPromise]);
    }
    finally {
        this.pageLoading = false;
        isPageLoading = false;
        this._navigatingToPage = false;
        this.pageLoadDelay = bluebird_1.default.resolve();
        if (onPageLoadedTimeout && pageReadinessPromise.isFulfilled()) {
            clearTimeout(onPageLoadedTimeout);
            onPageLoadedTimeout = null;
        }
        if (onTargetProvisioned) {
            this.rpcClient.targetSubscriptions.off(rpc_1.rpcConstants.ON_TARGET_PROVISIONED_EVENT, onTargetProvisioned);
        }
        if (onPageLoaded) {
            this.rpcClient.off('Page.loadEventFired', onPageLoaded);
        }
    }
    // enable console logging, so we get the events (otherwise we only
    // get notified when navigating to a local page
    try {
        await bluebird_1.default.resolve(this.rpcClient.send('Console.enable', {
            appIdKey: this.appIdKey,
            pageIdKey: this.pageIdKey,
        }, didPageFinishLoad)).timeout(CONSOLE_ENABLEMENT_TIMEOUT_MS);
    }
    catch (err) {
        if (err instanceof bluebird_1.default.TimeoutError) {
            throw new base_driver_1.errors.TimeoutError(`Could not enable console events after the page load within ` +
                `${CONSOLE_ENABLEMENT_TIMEOUT_MS}ms. The Web Inspector/Safari may need to be restarted.`);
        }
        throw err;
    }
}
exports.default = { frameDetached, cancelPageLoad, waitForDom, checkPageIsReady, navToUrl };
//# sourceMappingURL=navigate.js.map
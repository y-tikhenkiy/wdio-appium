"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IOSPerformanceLog = void 0;
const support_1 = require("appium/support");
const lodash_1 = __importDefault(require("lodash"));
const log = support_1.logger.getLogger('IOSPerformanceLog');
const MAX_EVENTS = 5000;
class IOSPerformanceLog {
    constructor(remoteDebugger, maxEvents = MAX_EVENTS) {
        this.remoteDebugger = remoteDebugger;
        this.maxEvents = parseInt(String(maxEvents), 10);
        this.timelineEvents = [];
    }
    async startCapture() {
        log.debug('Starting performance (Timeline) log capture');
        this.timelineEvents = [];
        return await this.remoteDebugger.startTimeline(this.onTimelineEvent.bind(this));
    }
    async stopCapture() {
        log.debug('Stopping performance (Timeline) log capture');
        return await this.remoteDebugger.stopTimeline();
    }
    onTimelineEvent(event) {
        log.debug(`Received Timeline event: ${lodash_1.default.truncate(JSON.stringify(event))}`);
        this.timelineEvents.push(event);
        // if we have too many, get rid of the oldest log line
        if (this.timelineEvents.length > this.maxEvents) {
            let removedEvent = this.timelineEvents.shift();
            log.warn(`Too many Timeline events, removing earliest: ${lodash_1.default.truncate(JSON.stringify(removedEvent))}`);
        }
    }
    // eslint-disable-next-line require-await
    async getLogs() {
        let events = this.timelineEvents;
        // flush events
        log.debug('Flushing Timeline events');
        this.timelineEvents = [];
        return events;
    }
    // eslint-disable-next-line require-await
    async getAllLogs() {
        return this.getLogs();
    }
}
exports.IOSPerformanceLog = IOSPerformanceLog;
exports.default = IOSPerformanceLog;
//# sourceMappingURL=ios-performance-log.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IOSCrashLog = void 0;
const support_1 = require("appium/support");
const bluebird_1 = __importDefault(require("bluebird"));
const logger_1 = __importDefault(require("../logger"));
const appium_ios_device_1 = require("appium-ios-device");
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const py_ios_device_client_1 = __importDefault(require("../py-ios-device-client"));
const REAL_DEVICE_MAGIC = '3620bbb0-fb9f-4b62-a668-896f2edc4d88';
const MAGIC_SEP = '/';
// The file format has been changed from '.crash' to '.ips' since Monterey.
const CRASH_REPORTS_GLOB_PATTERN = '**/*.@(crash|ips)';
/**
 * @typedef {Object} LogRecord
 * @property {number} timestamp
 * @property {string} level
 * @property {string} message
 */
class IOSCrashLog {
    constructor(opts = {}) {
        this.udid = opts.udid;
        this.pyideviceClient = this.udid ? new py_ios_device_client_1.default(this.udid) : null;
        const root = process.env.HOME || '/';
        const logDir = opts.udid
            ? path_1.default.resolve(root, 'Library', 'Logs', 'CrashReporter', 'MobileDevice')
            : path_1.default.resolve(root, 'Library', 'Logs', 'DiagnosticReports');
        this.logDir = logDir || path_1.default.resolve(root, 'Library', 'Logs', 'DiagnosticReports');
        this.prevLogs = [];
        this.logsSinceLastRequest = [];
        this.phoneName = null;
        this.sim = opts.sim;
    }
    /**
     * @returns {Promise<string[]>}
     */
    async _gatherFromRealDevice() {
        if (await this.pyideviceClient?.assertExists(false)) {
            return (await /** @type {Pyidevice} */ (this.pyideviceClient).listCrashes()).map((x) => `${REAL_DEVICE_MAGIC}${MAGIC_SEP}${x}`);
        }
        let crashLogsRoot = this.logDir;
        if (this.udid) {
            this.phoneName = this.phoneName || (await appium_ios_device_1.utilities.getDeviceName(this.udid));
            crashLogsRoot = path_1.default.resolve(crashLogsRoot, this.phoneName);
        }
        if (!(await support_1.fs.exists(crashLogsRoot))) {
            logger_1.default.debug(`Crash reports root '${crashLogsRoot}' does not exist. Got nothing to gather.`);
            return [];
        }
        return await support_1.fs.glob(CRASH_REPORTS_GLOB_PATTERN, {
            cwd: crashLogsRoot,
            absolute: true,
        });
    }
    /**
     * @returns {Promise<string[]>}
     */
    async _gatherFromSimulator() {
        if (!(await support_1.fs.exists(this.logDir))) {
            logger_1.default.debug(`Crash reports root '${this.logDir}' does not exist. Got nothing to gather.`);
            return [];
        }
        const foundFiles = await support_1.fs.glob(CRASH_REPORTS_GLOB_PATTERN, {
            cwd: this.logDir,
            absolute: true,
        });
        // For Simulator only include files, that contain current UDID
        return await bluebird_1.default.filter(foundFiles, async (x) => {
            try {
                const content = await support_1.fs.readFile(x, 'utf8');
                return content.toUpperCase().includes(this.sim.udid.toUpperCase());
            }
            catch (err) {
                return false;
            }
        });
    }
    /**
     * @returns {Promise<string[]>}
     */
    async getCrashes() {
        return this.udid ? await this._gatherFromRealDevice() : await this._gatherFromSimulator();
    }
    /**
     * @returns {Promise<void>}
     */
    async startCapture() {
        this.prevLogs = await this.getCrashes();
    }
    /**
     * @returns {Promise<void>}
     */
    async stopCapture() {
        // needed for consistent API with other logs
    }
    /**
     * @returns {Promise<LogRecord[]>}
     */
    async getLogs() {
        let crashFiles = await this.getCrashes();
        let diff = lodash_1.default.difference(crashFiles, this.prevLogs, this.logsSinceLastRequest);
        this.logsSinceLastRequest = lodash_1.default.union(this.logsSinceLastRequest, diff);
        return await this.filesToJSON(diff);
    }
    /**
     * @returns {Promise<LogRecord[]>}
     */
    async getAllLogs() {
        let crashFiles = await this.getCrashes();
        let logFiles = lodash_1.default.difference(crashFiles, this.prevLogs);
        return await this.filesToJSON(logFiles);
    }
    /**
     * @param {string[]} paths
     * @returns {Promise<LogRecord[]>}
     */
    async filesToJSON(paths) {
        const tmpRoot = await support_1.tempDir.openDir();
        try {
            return /** @type {LogRecord[]} */ ((await bluebird_1.default.map(paths, async (fullPath) => {
                if (lodash_1.default.includes(fullPath, REAL_DEVICE_MAGIC)) {
                    const fileName = /** @type {string} */ (lodash_1.default.last(fullPath.split(MAGIC_SEP)));
                    try {
                        // @ts-expect-error If pyideviceClient is not defined, then the exception will be caught below
                        await this.pyideviceClient.exportCrash(fileName, tmpRoot);
                    }
                    catch (e) {
                        logger_1.default.warn(`Cannot export the crash report '${fileName}'. Skipping it. ` +
                            `Original error: ${e.message}`);
                        return;
                    }
                    fullPath = path_1.default.join(tmpRoot, fileName);
                }
                const stat = await support_1.fs.stat(fullPath);
                return {
                    timestamp: stat.ctime.getTime(),
                    level: 'ALL',
                    message: await support_1.fs.readFile(fullPath, 'utf8'),
                };
            })).filter(Boolean));
        }
        finally {
            await support_1.fs.rimraf(tmpRoot);
        }
    }
}
exports.IOSCrashLog = IOSCrashLog;
exports.default = IOSCrashLog;
//# sourceMappingURL=ios-crash-log.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const bluebird_1 = __importDefault(require("bluebird"));
const driver_1 = require("appium/driver");
const ios_crash_log_1 = require("../device-log/ios-crash-log");
const ios_simulator_log_1 = require("../device-log/ios-simulator-log");
const ios_device_log_1 = require("../device-log/ios-device-log");
const logger_1 = __importDefault(require("../logger"));
const ws_1 = __importDefault(require("ws"));
const safari_console_log_1 = __importDefault(require("../device-log/safari-console-log"));
const safari_network_log_1 = __importDefault(require("../device-log/safari-network-log"));
/**
 * Determines the websocket endpoint based on the `sessionId`
 * @param {string} sessionId
 * @returns {string}
 */
const WEBSOCKET_ENDPOINT = (sessionId) => `${driver_1.DEFAULT_WS_PATHNAME_PREFIX}/session/${sessionId}/appium/device/syslog`;
const GET_SERVER_LOGS_FEATURE = 'get_server_logs';
/**
 * @type {import('@appium/types').LogDefRecord}
 * @privateRemarks The return types for these getters should be specified
 */
const SUPPORTED_LOG_TYPES = {
    syslog: {
        description: 'System Logs - Device logs for iOS applications on real devices and simulators',
        getter: async (self) => await self.extractLogs('syslog', self.logs),
    },
    crashlog: {
        description: 'Crash Logs - Crash reports for iOS applications on real devices and simulators',
        getter: async (self) => await self.extractLogs('crashlog', self.logs),
    },
    performance: {
        description: 'Performance Logs - Debug Timelines on real devices and simulators',
        getter: async (self) => await self.extractLogs('performance', self.logs),
    },
    safariConsole: {
        description: 'Safari Console Logs - data written to the JS console in Safari',
        getter: async (self) => await self.extractLogs('safariConsole', self.logs),
    },
    safariNetwork: {
        description: 'Safari Network Logs - information about network operations undertaken by Safari',
        getter: async (self) => await self.extractLogs('safariNetwork', self.logs),
    },
    server: {
        description: 'Appium server logs',
        /**
         * @returns {AppiumServerLogEntry[]}
         */
        getter: (self) => {
            self.assertFeatureEnabled(GET_SERVER_LOGS_FEATURE);
            return logger_1.default.unwrap().record.map((x) => ({
                timestamp: /** @type {any} */ (x).timestamp ?? Date.now(),
                level: 'ALL',
                message: lodash_1.default.isEmpty(x.prefix) ? x.message : `[${x.prefix}] ${x.message}`,
            }));
        },
    },
};
/**
 * Log entry in the array returned by `getLogs('server')`
 * @typedef AppiumServerLogEntry
 * @property {number} timestamp
 * @property {'ALL'} level
 * @property {string} message
 */
exports.default = {
    supportedLogTypes: SUPPORTED_LOG_TYPES,
    /**
     *
     * @param {XCUITestDriverLogTypes} logType
     * @param {Partial<Record<XCUITestDriverLogTypes,{getLogs(): Promise<any>}>>} [logsContainer]
     * @this {XCUITestDriver}
     */
    async extractLogs(logType, logsContainer = {}) {
        // make sure that we have logs at all
        // otherwise it's not been initialized
        if (lodash_1.default.isEmpty(logsContainer)) {
            throw new Error('No logs currently available. Is the device/simulator started?');
        }
        // If logs captured successfully send response with data, else send error
        const logObject = logsContainer[logType];
        const logs = logObject ? await logObject.getLogs() : null;
        if (logs) {
            return logs;
        }
        throw new Error(`No logs of type '${String(logType)}' found.`);
    },
    /**
     * @this {XCUITestDriver}
     */
    async startLogCapture() {
        this.logs = this.logs || {};
        if (!lodash_1.default.isUndefined(this.logs.syslog) && this.logs.syslog.isCapturing) {
            logger_1.default.warn('Trying to start iOS log capture but it has already started!');
            return true;
        }
        if (lodash_1.default.isUndefined(this.logs.syslog)) {
            this.logs.crashlog = new ios_crash_log_1.IOSCrashLog({
                sim: this.device,
                udid: this.isRealDevice() ? this.opts.udid : undefined,
            });
            if (this.isRealDevice()) {
                this.logs.syslog = new ios_device_log_1.IOSDeviceLog({
                    udid: this.opts.udid,
                    showLogs: this.opts.showIOSLog,
                });
            }
            else {
                this.logs.syslog = new ios_simulator_log_1.IOSSimulatorLog({
                    sim: this.device,
                    showLogs: this.opts.showIOSLog,
                    xcodeVersion: this.xcodeVersion,
                    iosSimulatorLogsPredicate: this.opts.iosSimulatorLogsPredicate,
                });
            }
            this.logs.safariConsole = new safari_console_log_1.default(!!this.opts.showSafariConsoleLog);
            this.logs.safariNetwork = new safari_network_log_1.default(!!this.opts.showSafariNetworkLog);
        }
        let didStartSyslog = false;
        /** @type {Promise[]} */
        const promises = [
            (async () => {
                try {
                    await this.logs.syslog.startCapture();
                    didStartSyslog = true;
                }
                catch (err) {
                    logger_1.default.debug(err.stack);
                    logger_1.default.warn(`Continuing without capturing device logs: ${err.message}`);
                }
            })(),
            this.logs.crashlog.startCapture(),
            this.logs.safariConsole.startCapture(),
            this.logs.safariNetwork.startCapture(),
        ];
        await bluebird_1.default.all(promises);
        return didStartSyslog;
    },
    /**
     * Starts an iOS system logs broadcast websocket.
     *
     * The websocket listens on the same host and port as Appium.  The endpoint created is `/ws/session/:sessionId:/appium/syslog`.
     *
     * If the websocket is already running, this command does nothing.
     *
     * Each connected webcoket listener will receive syslog lines as soon as they are visible to Appium.
     * @see https://appiumpro.com/editions/55-using-mobile-execution-commands-to-continuously-stream-device-logs-with-appium
     * @returns {Promise<void>}
     * @this {XCUITestDriver}
     */
    async mobileStartLogsBroadcast() {
        const pathname = WEBSOCKET_ENDPOINT(/** @type {string} */ (this.sessionId));
        if (!lodash_1.default.isEmpty(await /** @type {import('@appium/types').AppiumServer} */ (this.server).getWebSocketHandlers(pathname))) {
            logger_1.default.debug(`The system logs broadcasting web socket server is already listening at ${pathname}`);
            return;
        }
        logger_1.default.info(`Assigning system logs broadcasting web socket server to ${pathname}`);
        // https://github.com/websockets/ws/blob/master/doc/ws.md
        const wss = new ws_1.default.Server({
            noServer: true,
        });
        wss.on('connection', (ws, req) => {
            if (req) {
                const remoteIp = lodash_1.default.isEmpty(req.headers['x-forwarded-for'])
                    ? req.connection?.remoteAddress
                    : req.headers['x-forwarded-for'];
                logger_1.default.debug(`Established a new system logs listener web socket connection from ${remoteIp}`);
            }
            else {
                logger_1.default.debug('Established a new system logs listener web socket connection');
            }
            if (lodash_1.default.isEmpty(this._syslogWebsocketListener)) {
                this._syslogWebsocketListener = (logRecord) => {
                    if (ws?.readyState === ws_1.default.OPEN) {
                        ws.send(logRecord.message);
                    }
                };
            }
            this.logs.syslog.on('output', this._syslogWebsocketListener);
            ws.on('close', (code, reason) => {
                if (!lodash_1.default.isEmpty(this._syslogWebsocketListener)) {
                    this.logs.syslog.removeListener('output', this._syslogWebsocketListener);
                    this._syslogWebsocketListener = null;
                }
                let closeMsg = 'System logs listener web socket is closed.';
                if (!lodash_1.default.isEmpty(code)) {
                    closeMsg += ` Code: ${code}.`;
                }
                if (!lodash_1.default.isEmpty(reason)) {
                    closeMsg += ` Reason: ${reason.toString()}.`;
                }
                logger_1.default.debug(closeMsg);
            });
        });
        await /** @type {AppiumServer} */ (this.server).addWebSocketHandler(pathname, 
        /** @type {import('@appium/types').WSServer} */ (wss));
    },
    /**
     * Stops the syslog broadcasting wesocket server previously started by `mobile: startLogsBroadcast`.
     * If no websocket server is running, this command does nothing.
     * @this {XCUITestDriver}
     * @returns {Promise<void>}
     */
    async mobileStopLogsBroadcast() {
        const pathname = WEBSOCKET_ENDPOINT(/** @type {string} */ (this.sessionId));
        if (lodash_1.default.isEmpty(await /** @type {AppiumServer} */ (this.server).getWebSocketHandlers(pathname))) {
            return;
        }
        logger_1.default.debug('Stopping the system logs broadcasting web socket server');
        await /** @type {AppiumServer} */ (this.server).removeWebSocketHandler(pathname);
    },
};
/**
 * @typedef {import('../driver').XCUITestDriver} XCUITestDriver
 */
/**
 * @typedef {keyof typeof SUPPORTED_LOG_TYPES} XCUITestDriverLogTypes
 */
/**
 * @typedef {import('@appium/types').AppiumServer} AppiumServer
 */
//# sourceMappingURL=log.js.map